# ============================================================================
# SABR DERIVATIVES COMPUTATION (FAST VERSION)
# CPU parallel version – stable with pysabr
# IMPORTANT: pysabr.Hagan2002LognormalSABR constructor DOES NOT accept named args
# Must use positional order: (f, shift, t, alpha, beta, rho, volvol)
# ============================================================================

import numpy as np
import pandas as pd
from joblib import Parallel, delayed
from tqdm import tqdm

from pysabr.models.hagan_2002_lognormal_sabr import Hagan2002LognormalSABR


# ============================
# Fast scalar derivatives
# ============================

class SABRCalculator:

    def _make_sabr(self, f, alpha, beta, rho, volvol, t, shift=0.0):
        # IMPORTANT: positional args only (pysabr API requirement)
        return Hagan2002LognormalSABR(f, shift, t, alpha, beta, rho, volvol)

    def compute_all_derivatives(self, f, k, beta, rho, volvol, alpha, t):

        eps = 1e-4

        sabr_base = self._make_sabr(f, alpha, beta, rho, volvol, t)
        v_base = sabr_base.normal_vol(k)

        # beta
        v_up = self._make_sabr(f, alpha, beta + eps, rho, volvol, t).normal_vol(k)
        v_dn = self._make_sabr(f, alpha, beta - eps, rho, volvol, t).normal_vol(k)
        d_beta = (v_up - v_dn) / (2 * eps)

        # rho
        v_up = self._make_sabr(f, alpha, beta, rho + eps, volvol, t).normal_vol(k)
        v_dn = self._make_sabr(f, alpha, beta, rho - eps, volvol, t).normal_vol(k)
        d_rho = (v_up - v_dn) / (2 * eps)

        # volvol
        v_up = self._make_sabr(f, alpha, beta, rho, volvol + eps, t).normal_vol(k)
        v_dn = self._make_sabr(f, alpha, beta, rho, volvol - eps, t).normal_vol(k)
        d_volvol = (v_up - v_dn) / (2 * eps)

        # alpha (atm vol proxy)
        v_up = self._make_sabr(f, alpha + eps, beta, rho, volvol, t).normal_vol(k)
        v_dn = self._make_sabr(f, alpha - eps, beta, rho, volvol, t).normal_vol(k)
        d_alpha = (v_up - v_dn) / (2 * eps)

        # F
        v_up = self._make_sabr(f + eps, alpha, beta, rho, volvol, t).normal_vol(k)
        v_dn = self._make_sabr(f - eps, alpha, beta, rho, volvol, t).normal_vol(k)
        d_f = (v_up - v_dn) / (2 * eps)

        # K
        d_k = (
            sabr_base.normal_vol(k + eps) - sabr_base.normal_vol(k - eps)
        ) / (2 * eps)

        return [v_base, d_beta, d_rho, d_volvol, d_alpha, d_f, d_k]


# ============================
# Worker
# ============================


def _process_single_config(cfg):
    calc = SABRCalculator()
    f, strikes, beta, rho, volvol, alpha, t = cfg

    rows = []
    for k in strikes:
        vals = calc.compute_all_derivatives(f, k, beta, rho, volvol, alpha, t)
        rows.append([f, k, beta, rho, volvol, alpha, t] + vals)

    return rows


# ============================
# Main generator
# ============================


def generate_sabr_with_derivatives(num_samples=5000, num_strikes=8, n_jobs=-1):

    print("=" * 80)
    print("SABR DERIVATIVES COMPUTATION (FAST VERSION)")
    print("=" * 80)
    print("⚡ Parallel SABR generation...")

    BETAS = np.linspace(0.1, 0.9, 6)
    RHOS = np.linspace(-0.7, 0.7, 6)
    VOLVOLS = np.linspace(0.2, 1.0, 6)
    ALPHAS = np.linspace(0.05, 0.4, 6)
    FS = np.linspace(0.01, 0.05, 6)

    t = 1.0

    configs = []

    for beta in BETAS:
        for rho in RHOS:
            for volvol in VOLVOLS:
                for alpha in ALPHAS:
                    for f in FS:
                        strikes = np.linspace(0.8 * f, 1.2 * f, num_strikes)
                        configs.append((f, strikes, beta, rho, volvol, alpha, t))

    configs = configs[:num_samples]

    results = Parallel(n_jobs=n_jobs)(
        delayed(_process_single_config)(cfg)
        for cfg in tqdm(configs)
    )

    flat = [item for sublist in results for item in sublist]

    cols = [
        "f", "k", "beta", "rho", "volvol", "alpha", "t",
        "vol", "d_beta", "d_rho", "d_volvol", "d_alpha", "d_f", "d_k"
    ]

    return pd.DataFrame(flat, columns=cols)


if __name__ == "__main__":
    df = generate_sabr_with_derivatives()
    df.to_csv("sabr_dataset_with_derivatives.csv", index=False)
    print("✅ Done")